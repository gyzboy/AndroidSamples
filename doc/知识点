1、apk的启动流程:
一. Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；
二. ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；
三. Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，
    于是ActivityManagerService就创建一个新的进程，这个进程就是相应的应用进程。
    ActivityManagerService 通过 Socket 通信的方式和 Zygote 进行协商，Zygote 在其监听的 /dev/socket/zygote socket 中发现有需要创建进程的请求后，
    会 fork 自身，并返回相应的 Process Id用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；
四. ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，
    以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；
五. ActivityManagerService通过Binder进程间通信机制通知ActivityThread，上面创建的Process 会进行相应的初始化，使得其具备与系统服务进行 IPC 通信的能力,
在此之后，调用 ActivityThread 中的 main 方法，开启 Looper，主线程启动。

2.LruCache原理:
LruCache使用一个LinkedHashMap简单的实现内存的缓存，没有软引用，都是强引用。如果添加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。
他的主要原理在trimToSize方法中。需要了解两个主要的变量size和maxSize
maxSize是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。size在添加和移除缓存都被更新值，他通过safeSizeOf这个方法更新值。
safeSizeOf默认返回1，但一般我们会根据maxSize重写这个方法，比如认为maxSize代表是KB的话，那么就以KB为单位返回该项所占的内存大小。
除异常外首先会判断size是否超过maxSize,，如果超过了就取出最先插入的缓存，如果不为空就删掉（一般来说只要map不为空都不会返回null，因为他是个双休链表），并把size减去该项所占的大小。这个操作将一直循环下去，直到size比maxSize小或者缓存为空。

3.Webview相关
一、WebView缓存:
1）浏览器缓存机制；
2）Dom Storage（Web Storage）存储机制；
3）Web SQL Database 数据库缓存机制；
   String databaseDirPath = context.getDir("database",0).getPath();
   mWebView.getSettings().setDatabasePath(databaseDirPath);
4）Application Cache（AppCache）机制；
   String cacheDirPath = context.getDir("app_cache",0).getPath();
   mWebView.getSettings().setAppCachePath(cacheDirPath);
5）Indexed Database （IndexedDB）；
6）File System API；

二、WebView内存泄露:
1) 创建新进程承载webview,使用完后清除进程避免内存泄露
2) 使用自己封装的WebView:
   WebView webview = new WebView(context, attrs);
   ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
   webview.setLayoutParams(lp);
   swipeContainer.addView(webview);


三、Android Studio调试
1、异常断点:右键断点,勾选Java Exception Breakpoints，也可以在左上角选择Java Exception Breakpoints这样在发生
java异常时就会断点在发生异常的位置
2、条件断点:在断点处右键输入condition就可以当满足条件时自动挂起
3、日志断点:右键断点处,去掉suspend挂起状态,勾选上log的选项,在输入框里输入log内容,会输出到console目录
4、域断点:在对应域上加上断点即可,当这个域被修改时自动回调到修改处

四、android命令
dumpsys可以查看系统服务和状态，非常强大，可通过如下查看所有支持的子命令
adb shell dumpsys | grep "DUMP OF SERVICE" 列出dumpsys所支持的所有命令

adb install -r APK_FILE 重新安装并保留所有数据
adb shell am start PACKAGE_NAME/ACTIVITY_IN_PACKAGE 启动activity

adb shell input keyevent 82 解锁屏幕

adb logcat -s TAG_NAME_1 TAG_NAME_2 按签名过滤日志
adb logcat "*:W" 按日志等级过滤日志
adb logcat -s TEST: W 按签名和优先级同时过滤日志
adb logcat | grep "Exception\|Error"
adb logcat -c 清除缓存区并清除旧的日志

adb push /user/XXX sdcard/xx 电脑文件push到手机

adb bugreport > bugreport.txt  <= 6.0
adb bugreport bugreport.zip  >7.0
然后使用google的battery-historian 或者sony的ChkBugReport进行bug分析

adb shell --> sqlite3访问数据库
cat /proc/meminfo 查看内存信息
cat /proc/cpuinfo 查看CPU信息


五、Linux命令
which 查看命令路径 对应$PATH中的路径  which adb
find 命令:
find . 列出当前目录以及子目录的所有文件
find /home -name "*.txt" 在home下查找.txt后缀的所有文件  -iname 忽略大小写
find . -name "*.txt" -o -name "*.pdf" 查找所有txt和pdf结尾的文件
find /home ! -name "*.txt" 不是以txt结尾的文件
find . -maxdepth 3 -type f 最大深度为3类型为文件
find . -type f -atime -7 7天内被访问的文件 7天前使用 +7
find . -type f -atime 7 正好在7天前被访问的文件
find . -type f -name "*.txt" -delete 删除后缀名为txt的所有文件
locate /etc/sh 查找目录下所有以sh开头的文件

tail file 显示文件的最后10行
tail -f file 显示文件最新追加的内容
tail +20 file 显示文件从第20行到末尾
tail -c 10 file 显示文件最后10个字符

less -N file 显示文件pageUp、pageDown翻页 Q退出

cat -b file 显示file内容,忽略空白行编号
cat m1 m2 < file 输出m1、m2到file文件中

rm -i file 删除前询问用户
rm -rf file 强制删除file以及子目录下所有文件

mv ex3 new1 将ex3重命名为new1
mv /usr/men/* . 将/usr/men下的所有文件移动到当前目录

grep "xxx" file1 file2 --color=auto 在file1 file2 中输出包含xxx字符串的行并以颜色显示
grep -v "xxx" file 输出除了包含xxx字符串的行
grep -c "xxx" file 输出包含字符串xxx的行数

grep "main()" . -r --include *.{php,html}在所有.php和.html文件中遍历查找包含main字符串的行


六、Android中资源文件与资源ID之间的映射工作
在编译的时候，AAPT会扫描你所定义的所有资源（在不同文件中定义的以及单独的资源文件），然后给它们指定不同的资源ID。
资源ID 是一个32bit的数字，格式是PPTTNNNN ， PP代表资源所属的包(package) ,TT代表资源的类型(type)，NNNN代表这个类型下面的资源的名称。
对于系统应用的资源来说,PP的取值是0x01,对于应用程序的资源来说，PP的取值是0×7f。
TT 和NNNN 的取值是由AAPT工具随意指定的–基本上每一种新的资源类型的数字都是从上一个数字累加的（从1开始）；而每一个新的资源条目也是从数字1开始向上累加的。
所以如果我们的这几个资源文件按照下面的顺序排列，AAPT会依次处理：
 <code>layout/main.xml </code>

<code>drawable/icon.xml </code>

<code>layout/listitem.xml</code>
按照顺序，第一个资源的类型是”layout” 所以指定TT==1， 这个类型下面的第一个资源是”main” ，所以指定NNNN==1 ，最后这个资源就是0x7f010001。
第二个资源类型是”drawable”，所以指定TT==2，这个类型下的”icon” 指定NNNN ==1，所以最终的资源ID 是 0x7f020001。
第三个资源类型是”layout”，而这个资源类型在前面已经有定义了，所以TT仍然是1，但是”listitem”这个名字是新出现的，所以指定NNNN==2，因此最终的资源ID 就是 0x7f010002。
注意的是，AAPT在每一次编译的时候不会去保存上一次生成的资源ID标示，每当/res目录发生变化的时候，AAPT可能会去重新给资源指定ID号，然后重新生成一个R.java文件。
因此，在做开发的时候，你不应该在程序中将资源ID持久化保存到文件或者数据库。而资源ID在每一次编译后都有可能变化。
一旦资源被编译成二进制文件的时候，AAPT会生成R.java 文件和“resources.arsc”文件，“R.java”用于代码的编译，而”resources.arsc”则包含了全部的资源名称、资源ID和
资源的内容（对于单独文件类型的资源，这个内容代表的是这个文件在其.apk 文件中的路径信息）。这样就把运行环境中的资源ID 和具体的资源对应起来了。
在调试的时候，你可以使用“ aapt dump resources <apk的路径>”来看到对resources.arsc文件的详细描述信息。

七、NoClassDefFoundError与ClassNotFoundException区别
ClassNotFoundException:
1、class调用forName   2、classLoader调用findSystemClass  3、ClassLoader调用loadClass 多发生在在运行时调用这个类时找不到,在编译期无法
感知错误(使用error-prone可以发现问题)
NoClassDefFoundError:
JVM或者ClassLoader加载一个类(普通方法调用或者实例化一个对象)时发现class未定义,这时源码已经被编译,但是找不到这个类,多发生在类似于
jar的文件中,里面并不是所有所需要的类被加载进去,在编译期就会出错,可能发生于在静态域或者静态代码块初始化期间

八、屏幕密度相关:

      像素密度等级	等级像素密度	逻辑像素密度	屏幕像素	 屏幕尺寸(inch)	宽逻辑尺寸(dp单位)	 真实像素密度
ldpi      0.75	      120	        120	    240*320	   2.7	           w320dp	      140.55
mdpi      1	          160	        160	    320*480	   3.2	           w320dp	      180.27
hdpi      1.5	      240	        240	    480*800	   3.4	           w320dp	      274.39
xhdpi     2	          320	        320	    720*1280   4.65	           w360dp	      315.6
xhdpi     2	          320	        320	    768*1280   4.65	           w384dp	      321
xxhdpi    3	          480	        480	   1080*1920   4.95	           w360dp	      445
xxhdpi    3	          480	        420	   1080*1920   5.2	           w411dp	      423
xxxdpi    4	          640	        560	   1440*2560   5.96	           w411dp	      493







