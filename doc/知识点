1、apk的启动流程:
一. Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；
二. ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；
三. Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，
    于是ActivityManagerService就创建一个新的进程，这个进程就是相应的应用进程。
    ActivityManagerService 通过 Socket 通信的方式和 Zygote 进行协商，Zygote 在其监听的 /dev/socket/zygote socket 中发现有需要创建进程的请求后，
    会 fork(复制) 自身，并返回相应的 Process Id用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；
四. ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，
    以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；
五. ActivityManagerService通过Binder进程间通信机制通知ActivityThread，上面创建的Process 会进行相应的初始化，使得其具备与系统服务进行 IPC 通信的能力,
在此之后，调用 ActivityThread 中的 main 方法，开启 Looper，主线程启动。

2.LruCache原理:
LruCache使用一个LinkedHashMap简单的实现内存的缓存，没有软引用，都是强引用。如果添加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。
他的主要原理在trimToSize方法中。需要了解两个主要的变量size和maxSize
maxSize是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。size在添加和移除缓存都被更新值，他通过safeSizeOf这个方法更新值。
safeSizeOf默认返回1，但一般我们会根据maxSize重写这个方法，比如认为maxSize代表是KB的话，那么就以KB为单位返回该项所占的内存大小。
除异常外首先会判断size是否超过maxSize,，如果超过了就取出最先插入的缓存，如果不为空就删掉（一般来说只要map不为空都不会返回null，因为他是个双休链表），并把size减去该项所占的大小。这个操作将一直循环下去，直到size比maxSize小或者缓存为空。

3.Webview相关
一、WebView缓存:
1）浏览器缓存机制；
2）Dom Storage（Web Storage）存储机制；
3）Web SQL Database 数据库缓存机制；
   String databaseDirPath = context.getDir("database",0).getPath();
   mWebView.getSettings().setDatabasePath(databaseDirPath);
4）Application Cache（AppCache）机制；
   String cacheDirPath = context.getDir("app_cache",0).getPath();
   mWebView.getSettings().setAppCachePath(cacheDirPath);
5）Indexed Database （IndexedDB）；
6）File System API；

二、WebView内存泄露:
1) 创建新进程承载webview,使用完后清除进程避免内存泄露
2) 使用自己封装的WebView:
   WebView webview = new WebView(context, attrs);
   ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
   webview.setLayoutParams(lp);
   swipeContainer.addView(webview);


三、Android Studio调试
1、异常断点:右键断点,勾选Java Exception Breakpoints，也可以在左上角选择Java Exception Breakpoints这样在发生
java异常时就会断点在发生异常的位置
2、条件断点:在断点处右键输入condition就可以当满足条件时自动挂起
3、日志断点:右键断点处,去掉suspend挂起状态,勾选上log的选项,在输入框里输入log内容,会输出到console目录
4、域断点:在对应域上加上断点即可,当这个域被修改时自动回调到修改处

四、android命令
dumpsys可以查看系统服务和状态，非常强大，可通过如下查看所有支持的子命令
adb shell dumpsys | grep "DUMP OF SERVICE" 列出dumpsys所支持的所有命令

adb install -r APK_FILE 重新安装并保留所有数据
adb shell am start PACKAGE_NAME/ACTIVITY_IN_PACKAGE 启动activity

adb shell am start -w packagename/activityname 计算app启动时间,返回三个值
ThisTime: 表示一连串启动 Activity 的最后一个 Activity 的启动耗时
WaitTime: 就是总的耗时，包括前一个应用 Activity pause 的时间和新应用启动的时间
TotalTime: 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前
          一个应用 Activity pause 的耗时

adb shell input keyevent 82 解锁屏幕

adb logcat -s TAG_NAME_1 TAG_NAME_2 按签名过滤日志
adb logcat "*:W" 按日志等级过滤日志
adb logcat -s TEST: W 按签名和优先级同时过滤日志
adb logcat | grep "Exception\|Error"
adb logcat -c 清除缓存区并清除旧的日志

adb push /user/XXX sdcard/xx 电脑文件push到手机

adb bugreport > bugreport.txt  <= 6.0
adb bugreport bugreport.zip  >7.0
然后使用google的battery-historian 或者sony的ChkBugReport进行bug分析

adb shell --> sqlite3访问数据库

/proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为内核与进程提供通信的接口。
系统中当前运行的每一个进程在/proc下都对应一个以进程号为目录名的目录/proc/pid，它们是读取进程信息的接口。此外，在Linux 2.6.0-test6以上的版本中/proc/pid目录中有一个task目录，
/proc/pid/task目录中也有一些以该进程所拥有的线程的线程号命名的目录/proc/pid/task/tid，它们是读取线程信息的接口
cat /proc/meminfo 查看内存信息
cat /proc/cpuinfo 查看CPU信息
/proc/" + Pid + "/task/" + ThreadId + "/sched  读取线程信息,关注wait_sum,sum_exec_runtime,wait_max,wait_count,iowait_sum,iowait_count
/proc/" + pid + "/stat 该文件包含了某一进程所有的活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。
adb shell -> run as packageName cd data/data/...访问私有文件


五、Linux命令
which 查看命令路径 对应$PATH中的路径  which adb
find 命令:
find . 列出当前目录以及子目录的所有文件
find /home -name "*.txt" 在home下查找.txt后缀的所有文件  -iname 忽略大小写
find . -name "*.txt" -o -name "*.pdf" 查找所有txt和pdf结尾的文件
find /home ! -name "*.txt" 不是以txt结尾的文件
find . -maxdepth 3 -type f 最大深度为3类型为文件
find . -type f -atime -7 7天内被访问的文件 7天前使用 +7
find . -type f -atime 7 正好在7天前被访问的文件
find . -type f -name "*.txt" -delete 删除后缀名为txt的所有文件
find `find . -name res` -name "*.xml" | grep status_bar_size 查找res文件夹下的所有包含status_bar_size字符串的xml文件

locate /etc/sh 查找目录下所有以sh开头的文件

tail file 显示文件的最后10行
tail -f file 显示文件最新追加的内容
tail +20 file 显示文件从第20行到末尾
tail -c 10 file 显示文件最后10个字符

less -N file 显示文件pageUp、pageDown翻页 Q退出

//连接文件内容并输出
cat -b file 显示file内容,忽略空白行编号
cat m1 m2 < file 输出m1、m2到file文件中

rm -i file 删除前询问用户
rm -rf file 强制删除file以及子目录下所有文件

mv ex3 new1 将ex3重命名为new1
mv /usr/men/* . 将/usr/men下的所有文件移动到当前目录

grep "xxx" file1 file2 --color=auto 在file1 file2 中输出包含xxx字符串的行并以颜色显示
grep -v "xxx" file 输出除了包含xxx字符串的行
grep -c "xxx" file 输出包含字符串xxx的行数

grep "main()" . -r --include *.{php,html}在所有.php和.html文件中遍历查找包含main字符串的行


六、Android中资源文件与资源ID之间的映射工作
在编译的时候，AAPT会扫描你所定义的所有资源（在不同文件中定义的以及单独的资源文件），然后给它们指定不同的资源ID。
资源ID 是一个32bit的数字，格式是PPTTNNNN ， PP代表资源所属的包(package) ,TT代表资源的类型(type)，NNNN代表这个类型下面的资源的名称。
对于系统应用的资源来说,PP的取值是0x01,对于应用程序的资源来说，PP的取值是0×7f。
TT 和NNNN 的取值是由AAPT工具随意指定的–基本上每一种新的资源类型的数字都是从上一个数字累加的（从1开始）；而每一个新的资源条目也是从数字1开始向上累加的。
所以如果我们的这几个资源文件按照下面的顺序排列，AAPT会依次处理：
 <code>layout/main.xml </code>

<code>drawable/icon.xml </code>

<code>layout/listitem.xml</code>
按照顺序，第一个资源的类型是”layout” 所以指定TT==1， 这个类型下面的第一个资源是”main” ，所以指定NNNN==1 ，最后这个资源就是0x7f010001。
第二个资源类型是”drawable”，所以指定TT==2，这个类型下的”icon” 指定NNNN ==1，所以最终的资源ID 是 0x7f020001。
第三个资源类型是”layout”，而这个资源类型在前面已经有定义了，所以TT仍然是1，但是”listitem”这个名字是新出现的，所以指定NNNN==2，因此最终的资源ID 就是 0x7f010002。
注意的是，AAPT在每一次编译的时候不会去保存上一次生成的资源ID标示，每当/res目录发生变化的时候，AAPT可能会去重新给资源指定ID号，然后重新生成一个R.java文件。
因此，在做开发的时候，你不应该在程序中将资源ID持久化保存到文件或者数据库。而资源ID在每一次编译后都有可能变化。
一旦资源被编译成二进制文件的时候，AAPT会生成R.java 文件和“resources.arsc”文件，“R.java”用于代码的编译，而”resources.arsc”则包含了全部的资源名称、资源ID和
资源的内容（对于单独文件类型的资源，这个内容代表的是这个文件在其.apk 文件中的路径信息）。这样就把运行环境中的资源ID 和具体的资源对应起来了。
在调试的时候，你可以使用“ aapt dump resources <apk的路径>”来看到对resources.arsc文件的详细描述信息。

七、NoClassDefFoundError与ClassNotFoundException区别
ClassNotFoundException:
1、class调用forName   2、classLoader调用findSystemClass  3、ClassLoader调用loadClass 多发生在在运行时调用这个类时找不到,在编译期无法
感知错误(使用error-prone可以发现问题)
NoClassDefFoundError:
JVM或者ClassLoader加载一个类(普通方法调用或者实例化一个对象)时发现class未定义,这时源码已经被编译,但是找不到这个类,多发生在类似于
jar的文件中,里面并不是所有所需要的类被加载进去,在编译期就会出错,可能发生于在静态域或者静态代码块初始化期间

八、屏幕密度相关:

      像素密度等级	等级像素密度	逻辑像素密度	屏幕像素	 屏幕尺寸(inch)	宽逻辑尺寸(dp单位)	 真实像素密度
ldpi      0.75	      120	        120	    240*320	   2.7	           w320dp	      140.55
mdpi      1	          160	        160	    320*480	   3.2	           w320dp	      180.27
hdpi      1.5	      240	        240	    480*800	   3.4	           w320dp	      274.39
xhdpi     2	          320	        320	    720*1280   4.65	           w360dp	      315.6
xhdpi     2	          320	        320	    768*1280   4.65	           w384dp	      321
xxhdpi    3	          480	        480	   1080*1920   4.95	           w360dp	      445
xxhdpi    3	          480	        420	   1080*1920   5.2	           w411dp	      423
xxxdpi    4	          640	        560	   1440*2560   5.96	           w411dp	      493
nopdi 文件夹下的图片会按照实际像素显示,不会根据密度进行缩放
drawable 与 mdpi 相同

九、Android的Library中不能使用switch语句
这是由于library的R.java中的资源ID不是常量引起的，我们可以在library中通过if-else-if条件语句来引用资源ID，这样就避免了这个错误

十、Android内存泄漏
手动触发GC后，通过adb shell dumpsys meminfo packagename -d查看Activity和View的数量

对于性能问题，分析和改善有必要遵循以下原则：
1、一切看数据说话，不能跟着感觉走，感觉哪有问题就去改，很有可能会适得其反；
2、性能优化是一个持续的过程，需要不断地改善，不要想着一气呵成；
3、对于性能问题，不一定必须要改善，受限于架构或者其它原因某些问题可能会很难改善，必须要先保证能用，再才考虑好用。
4、改善后一定要验证，任何一个地方的改动都需要验证，避免因为改善性能问题导致其它的问题。

常见的内存泄露问题:
1、定义 Activity 时在内部定义一个静态变量，并将其值设置为处于运行状态的 Activity 。如果在 Activity 生命周期结束时没有清除引用的话，这个 Activity 就会泄漏。
2、静态的View
3、非静态内部类导致的内存泄露，内部类在它的整个生命周期中是会访问外部类。比如Handler，解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例
4、IO操作后，没有关闭文件导致的内存泄露，比如Cursor、FileInputStream、FileOutputStream使用完后没有关闭，这种问题在Android Studio 2.0中能够通过静态代码分析检查出来，直接改善就可以了
5、自定义View中使用TypedArray后，没有recycle，这种问题也可以在Android Studio 2.0中能够通过静态代码分析检查出来，直接改善就可以了
6、同一个APP，将图片放在不同的drawable文件夹下，在相同的设备上占用的内存情况不一样,尽量放在xxhdpi中,适配主流屏幕,如果放在mdpi中的图片，在xxhdpi屏幕的手机上1dp=3px,所以会放大9倍,所占内存扩大了9倍
内存占用计算公式:w * h * 4(ARGB4个通道) 单位byte

十一、ClassLoader总结
PathClassLoader: 主要用于系统和app的类加载器,其中optimizedDirectory为null, 采用默认目录/data/dalvik-cache/
DexClassLoader: 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载,但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多插件化方案都是采用DexClassLoader;
BaseDexClassLoader: 比较基础的类加载器, PathClassLoader和DexClassLoader都只是在构造函数上对其简单封装而已.
BootClassLoader: 作为父类的类构造器.

十二、Android OOM Killer
proc/pid下有几个值可以查看Android的OOM阈值
proc/pid/oom_adj:
1、前台进程 （Active Process）： oom_adj为0。
前台进程包括 ： 1：活动 正在前台接收用户输入
              2：活动、服务与广播接收器正在执行一个onReceive事件的处理函数
              3： 服务正在运行 onStart、onCreate或onDestroy事件处理函数。

2、已启动服务的进程(Started Service Process) ：oom_adj值为0，这类进程包含一个已启动的服务。 服务并不直接与用户输入交互，因此服务的优先级
低于可见活动的优先级，但是，已启动服务的进程任被认为是前台进程，只有在活动以及可见活动需要资源时，已启动服务的进程才会被杀死。
3、可见进程 （Visible Process）: oom_adj 为 1。活动是可见的，但并不在前台，或者不响应用户的输入。例如，活动被非全屏或者透明的活动所遮挡。
4、后台进程 （Backgroud Process）: oom_adj 值为 2，这类进程不包含任何可见的活动与启动的服务。通常大量后台进程存在时，系统会采用（last-seen-first-kill）后见先杀的方式，释放资源为前台进程使用。
5、主界面 （home process）： oom_adj 为 4
6、隐藏进程 （hidden process）： oom_adj为 7
7、内容提供者 （content provider）：oom_adj 为 14
8、空进程 （Empty process）：oom_adj为 15

oom_score的分数越高就越会被内核优先杀掉

通过cat proc/pid/oom_adj 查看值

十三、过度绘制
颜色标识: 从好到差:蓝-绿-淡红-红
1. 蓝色1x过度绘制
2. 绿色2x过度绘制
3. 淡红色3x过度绘制
4. 红色超过4x过度绘制

1.减少多余的background
2.可复用组建使用include或者style的方式减少大量代码.
3.viewStub的引入减少不长用的布局View的添加
4.减少层级
5.this.getWindow().setBackgroundDrawable(null);的方式去设置背景，这个要谨慎使用，在低端机上的使用可能会造成闪屏的情况

十四、ANTI_ALIAS_FLAG减少绘制边缘锯齿
ANTI_ALIAS_FLAG 通过混合前景色与背景色来产生平滑的边缘,当我们在 Bitmap 上重绘时，像素的颜色会越来越纯粹导致边缘越来越粗糙。
这就是为什么设置了 ANTI_ALIAS_FLAG 后你们图形的边缘还是十分粗糙。

如何避免这个问题:
1、避免重绘
2、在重绘前清空Bitmap

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (bitmap == null) {
            bitmap = Bitmap.createBitmap(200,
                                         200,
                                         Bitmap.Config.ARGB_8888);
            bitmapCanvas = new Canvas(bitmap);
        }
        bitmapCanvas.drawColor(
                  Color.TRANSPARENT,
                  PorterDuff.Mode.CLEAR); //this line moved outside if
        drawOnCanvas(bitmapCanvas);
        canvas.drawBitmap(bitmap, mLeftX, mTopY, p);
    }

十五、不要用Application缓存数据
Application对象并不是始终在内存中的，它有可能会由于系统内存不足而被杀掉。但Android在你恢复这个应用时并不是重新开始启动这个应用，
它会创建一个新的Application对象并且启动上次用户离开时的activity以造成这个app从来没有被kill掉得假象。

十六、gradle脚本中debugCompile project
因为在library项目中默认只会执行compileRelease而不是预想中的compileDebug,这就会导致library项目中的BuildConfig.DEBUG一直返回false,要解决这个问题
可以指定编译参数,
publishNonDefault true //需要加上该参数否则会提示debug not found
debugCompile project(path: ‘:train’, configuration: ‘debug’)

十七、获取前台运行进程
1、通过getRunningTasks获取当前topActivity,通过topActivity的getProcess判断是否是当前进程,此方法在5.0以上失效
2、通过getRunningAppProcesses的IMPORTANCE_FOREGROUND属性判断是否位于前台，当service需要常驻后台时候，此方法失效,分机型
3、通过使用UsageStatsManager获取,5.0以上有用
4、读取/proc目录下/proc/pid/cmdline，再根据进程的属性判断是否为前台

十八、看似View不继承于View的"View"
Toast--->show的时候通过aidl将show事件enqueueToast到notification服务中,makeText的时候动态的new出一个Toast对象,inflate布局
PopupWindow--->附着在window上
Dialog--->附着在window上,默认显示在center位置
ViewRoot--->继承与Handler,主要是把WMS的IPC调用转换为本地的一个异步调用

十九、FrameWork框架
服务端(Android手机):Wms与Ams,一个用于显示,一个用于管理Activity，两个消息处理类:KeyQ(Wms内部类,会启动一个线程,不断读取用户的UI操作信息)
InputDispatcherThread:会启动一个线程,不断的从QueueEvent中取出用户消息,并进行一定的过滤,再分发给当前客户端程序中

客户端(App应用):
ActivityThread:UI线程或者主线程
Activity:APK运行的最小单元
PhoneWindow:继承与Window,是一个内部含有View对象(DecordView),并提供一组通用窗口操作API
Window:一个抽象类,Wms所管理的窗口不是window类,而是一个view或者viewGroup,对于phoneWindow而言就是decordView
DecordView:是FrameLayout的子类
ViewRoot:继承与Handler,将Wms的IPC调用转为本地的一个异步调用
W:继承于Binder,是ViewRoot的一个内部类,是ViewRoot类内部用于Wms的IPC调用

Activity启动后会创建一个ViewRoot.W和ApplicationThread,两者都继承于Binder,再启动一个UI线程ActivityThread

二十、



